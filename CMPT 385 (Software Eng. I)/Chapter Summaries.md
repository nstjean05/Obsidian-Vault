# Ch. 1 – Software and Software Engineering
- 



















# Ch. 2 – Process Models
- Process Models --> Framework of activities actions, and work tasks.
	- Various models have different flows, organized sequentially or chronologically.
	- These patterns are useful for solving common software process challenges.
### Prescriptive Models
- Bring order and structure to software development.
- Vary, but have the same framework of generic activities.
	- Communication
	- Planning
	- Modelling
	- Construction
#### Sequential
- Older paradigms such as the waterfall model.
	- Communication > Planning > Modelling > Construction > Deployment
	- Each can only begin when the prior is complete.
- Linear process flow
	- Often inconsistent with reality.
#### Incremental
- Iterative in nature, and quickly produce a working version of software
- Includes the prototyping and spiral model.
- **Prototyping Model**
	- Good when the customer has a lot of unknown variables.
	- Communication > Quick Plan > Modelling and Quick Design > Prototype > Deployment/Feedback > More Communication
- **Spiral Model**
	- Start in the middle, and spiral out.
	- Begin with communication > planning > modelling > construction > deployment/feedback > communication
	- Useful for designing large-scale systems
#### Unified Process Model
- Similar to the spiral model, but conducted in increments after each deployment.
# Ch. 3 – Agility and Process
- Agile is optimized for modern, rapidly changing market conditions
- There are four key issues:
	1. Self-organizing teams with control over their work.
	2. Communication and collaboration between team members, practitioners, and customers.
	3. Recognition that change represents an opportunity.
	4. Rapid delivery of software the satisfies the customer.
- Agile can greatly lower the cost of change as the project progresses.
- Criticized for not holding up at organizational-scale development.
#### Scrum
- 15-min meeting each 24 hours, over a period of 4 weeks (a sprint).
- 3 Questions at each meeting:
	1. What did you do since last meeting?
	2. What obstacles do you have?
	3. What do you plan to do by next meeting?
# Ch. 4 – Recommended Process Model
- There are some fundamental steps to remember about road maps:
	1. Communication
	2. Planning
	3. Modelling
	4. Construction
	5. Deployment
- **Evolutionary Process Models**
	- Flexible planning, frequent stakeholder involvement
	- Incremental prototyping
	- Limited requirements, documents, and models allows early prototype production.
- Making use of paper prototypes early on can avoid making products which don't satisfy customer expectations.
- You can only know all the requirements once the software has been delivered.
- Risk assessment and acceptance are important in assessing prototypes.
- Make sure that the scope of a project doesn't get out of hand.
# Ch. 5 - Human Aspects of SW Engineering
- A successful software engineer must have good technical and interpersonal skills.
	- Responsible for commitments
	- Aware of peers
	- Give honest assesments
- A **jelled** software team is more productive and effective.
	1. Sense of purpose
	2. Trust
	3. Involvement
	4. Sense of improvement
	5. Avoid toxicity
- Agile teams have more autonomy than conventional teams.
	1. Communication
	2. Simplicity
	3. Feedback
	4. Courage
	5. Respect
- Social media and electronic comms are highly important for remote projects.
# Ch. 7 - Understanding Requirements
- Requirements engineering tasks are conducted to establish a solid foundation for design and construction.
	- Occurs during communication and modelling (as described in the teams processes.)
-  Seven requirement engineering activities:
	1. Inception
	2. Elicitation
	3. Elaboration
	4. Negotiation
	5. Specification
	6. Validation
	7. Management
- At inception, stakeholders establish basic requirements
	- Define constraints
	- Address major features
- Elaboration is a series of elements built of scenarios, activities, classes, and behaviours.
- As requirements are identified, software team/stakeholders must negotiate the priority and cost of each task.
# Ch. 8 - Requirements Modelling—A Recommended Approach
- Create a variety of representations that describe what the customer requires.
- Requirements model bridges gap between system-level description and business functionality.
- User stories help create scenario-based models
- Class-based modelling takes information from use cases to identify analysis classes.
- UML is helpful for organizing a program's components
- Behavioural modelling during requirements analysis takes input from the prior models, and analyses them.
# Ch. 9 - Design Concepts
- Design Goal: To create a model of software to implement all the customer requirements.
	- Converge on a solution that best suits the stakeholder's needs
- Design concepts emphasize the need for abstraction.
- Four elements of design:
	1. Architecture
		- Complete structural representation of the software.
	2. Interface
		- External and internal interfaces and UI
	3. Components
		- Modules of the architecture
	4. Deployment
		- Physical Configuration
# Ch. 10 – Architectural design
- Holistic view of the system to be built
- Architectural design has four steps:
	1. System in context
		- Define externalities
	2. Archetypes (top level abstractions)
	3. Implementation domain
	4. Specific instantiations of the architecture.
- Each level of the design gets more specific.
# Ch. 11 – Component-Level Design
- Slowly reduce the level of abstraction
- 3 Views of component-level data:
	1. Object Oriented
	2. Traditional
		- Representation of data structures, interfaces, and languages
	3. Process
- Make sure to be refactoring at every stage.
- Component-level design must consider both content and functionality.
# Ch. 12 - User Experience Design
- Arguable the most important element of a computer-based system.
- 3 Important design principles:
	1. Place the user in control
	2. Reduce the user's memory load
	3. Make the interface consistent.
- Begin UX development with a series of tasks
- Define personas for the profiles of users.
- Create interface objects and actions for screen layout.
- Address design issues
	- Response time
	- Command and action structure
	- Error handling
	- Help facilities
# Ch. 14 - Pattern-based Design
- Patters describe a problem, enabling the user to understand what is happening
- Many pattern domains:
	- Architectural
		- Broad design problems
	- Data
		- Recurring dat problems and modelling issues
	- Component
		- aka design patterns
		- development of subsystems
	- Software anti-patterns
		- Common solutions to a problem
		- Lead to poor software quality
# Ch. 15 - Quality Concepts
- 



















# Ch. 17 - SW Quality Assurance
- Umbrella activity applied at each step of the process.
- Effective application of methods and tools
	- Technical reviews and software testing
	- Procedures for change management
	- Compliance to standards
	- Measurement and reporting mechanisms
- Mapping of managerial precepts onto applicable managerial and technical space of SW Engineering
# Ch. 19 - SW Testing - Component Level
- SW Testing accounts for the largest part of technical effort in the SW process
- Consider the small elements and move outward towards the program as a whole
- Condition and data flow testing exercise program logic.



















# Ch. 20 - SW Testing - Integration Level




















# Ch. 22 – Project Management




















# Ch. 23 – SW Metrics and Analytics




















# Ch. 24 – Project Management Concepts




















# Ch. 25 – Creating a Viable Software Plan


















