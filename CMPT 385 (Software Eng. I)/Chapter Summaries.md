# Ch. 1 – Software and Software Engineering
- 



















# Ch. 2 – Process Models
- Process Models --> Framework of activities actions, and work tasks.
	- Various models have different flows, organized sequentially or chronologically.
	- These patterns are useful for solving common software process challenges.
### Prescriptive Models
- Bring order and structure to software development.
- Vary, but have the same framework of generic activities.
	- Communication
	- Planning
	- Modelling
	- Construction
#### Sequential
- Older paradigms such as the waterfall model.
	- Communication > Planning > Modelling > Construction > Deployment
	- Each can only begin when the prior is complete.
- Linear process flow
	- Often inconsistent with reality.
#### Incremental
- Iterative in nature, and quickly produce a working version of software
- Includes the prototyping and spiral model.
- **Prototyping Model**
	- Good when the customer has a lot of unknown variables.
	- Communication > Quick Plan > Modelling and Quick Design > Prototype > Deployment/Feedback > More Communication
- **Spiral Model**
	- Start in the middle, and spiral out.
	- Begin with communication > planning > modelling > construction > deployment/feedback > communication
	- Useful for designing large-scale systems
#### Unified Process Model
- Similar to the spiral model, but conducted in increments after each deployment.
# Ch. 3 – Agility and Process
- Agile is optimized for modern, rapidly changing market conditions
- There are four key issues:
	1. Self-organizing teams with control over their work.
	2. Communication and collaboration between team members, practitioners, and customers.
	3. Recognition that change represents an opportunity.
	4. Rapid delivery of software the satisfies the customer.
- Agile can greatly lower the cost of change as the project progresses.
- Criticized for not holding up at organizational-scale development.
#### Scrum
- 15-min meeting each 24 hours, over a period of 4 weeks (a sprint).
- 3 Questions at each meeting:
	1. What did you do since last meeting?
	2. What obstacles do you have?
	3. What do you plan to do by next meeting?
# Ch. 4 – Recommended Process Model
- There are some fundamental steps to remember about road maps:
	1. Communication
	2. Planning
	3. Modelling
	4. Construction
	5. Deployment
- **Evolutionary Process Models**
	- Flexible planning, frequent stakeholder involvement
	- Incremental prototyping
	- Limited requirements, documents, and models allows early prototype production.
- Making use of paper prototypes early on can avoid making products which don't satisfy customer expectations.
- You can only know all the requirements once the software has been delivered.
- Risk assessment and acceptance are important in assessing prototypes.
- Make sure that the scope of a project doesn't get out of hand.
# Ch. 5 - Human Aspects of SW Engineering
- A successful software engineer must have good technical and interpersonal skills.
	- Responsible for commitments
	- Aware of peers
	- Give honest assesments
- A **jelled** software team is more productive and effective.
	1. Sense of purpose
	2. Trust
	3. Involvement
	4. Sense of improvement
	5. Avoid toxicity
- Agile teams have more autonomy than conventional teams.
	1. Communication
	2. Simplicity
	3. Feedback
	4. Courage
	5. Respect
- Social media and electronic comms are highly important for remote projects.
# Ch. 7 - Understanding Requirements
- Requirements engineering tasks are conducted to establish a solid foundation for design and construction.
	- Occurs during communication and modelling (as described in the teams processes.)
-  Seven requirement engineering activities:
	1. Inception
	2. Elicitation
	3. Elaboration
	4. Negotiation
	5. Specification
	6. Validation
	7. Management
- At inception, stakeholders establish basic requirements
	- Define constraints
	- Address major features
- Elaboration is a series of elements built of scenarios, activities, classes, and behaviours.
- As requirements are identified, software team/stakeholders must negotiate the priority and cost of each task.
# Ch. 8 - Requirements Modelling—A Recommended Approach
- Create a variety of representations that describe what the customer requires.
- Requirements model bridges gap between system-level description and business functionality.
- User stories help create scenario-based models
- Class-based modelling takes information from use cases to identify analysis classes.
- UML is helpful for organizing a program's components
- Behavioural modelling during requirements analysis 



















# Ch. 9 - Design Concepts




















# Ch. 10 – Architectural design




















# Ch. 11 – Component-Level Design




















# Ch. 12 - User Experience Design




















# Ch. 14 - Pattern-based Design




















# Ch. 15 - Quality Concepts




















# Ch. 17 - SW Quality Assurance




















# Ch. 19 - SW Testing - Component Level




















# Ch. 20 - SW Testing - Integration Level




















# Ch. 22 – Project Management




















# Ch. 23 – SW Metrics and Analytics




















# Ch. 24 – Project Management Concepts




















# Ch. 25 – Creating a Viable Software Plan


















